# Query Abbreviation in Presto

## Motivation

* Query-list.js makes a call to /v1/query/ endpoint, which returns a long list of queries. At times, when “query” field in QueryInfo object is too long (~1MB) for several queries, the REST call ends up fetching a lot of data from Presto Server. Instead of the whole query strings, sending a shorter version may allow us to reduce overall size of the response.

* (1) Pagination of query responses OR (2) Truncation of query strings are simple approaches that first come to mind to resolve this. The code in this PR takes a third approach, something a bit more involved, generating a shorter “abridged” version (that has length <= a configurable parameter L) for a query string without losing its sense. This can still be combined with approach (1) if required. And in case we fail to produce an abridged version <= L, we fall back to approach (2), i.e. truncation.

* Meaningful abbreviation of query strings seemed like an interesting problem in its own. For example, 

if we have a query

	`Select * from table_name where col1_name not in [‘val_1’, ‘val_2’, ….. ‘Val_2000’] and col2_name <= val_0.`

After shortening, it would be better to have 

	`Select * from table_name where col1_name not in [...] and col2_name <= 5`

Instead of

	`Select * from table_name where col1_name not in [‘val_1’, ‘val_2’, ‘val_3’, ‘v`
  
## Overview:

At a high level, the query abbreviation has been implemented as follows:

* An abridged version of the query string is generated by invoking the QueryAbbreviator during the creation of QueryStateMachine object. This object is passed to BasicQueryInfo constructor instead of the query itself, while returning the response from /v1/query endpoint.
* QueryAbbreviator does the following:
  + Generates a tree from the query string S using SqlParser. 
  + It keeps pruning nodes one-by-one from the tree until
    + The SQL that will be generated by the tree will have length <= L. OR
    + All the prunable nodes have already been pruned from the tree.

  + Returns the query string generated from the pruned tree. 


## Algorithm for abbreviation:

1. Generate a queue Q of nodes to prune. Only the nodes that return true from AbbreviatorUtil::isAllowedToBePruned can be added to the queue. In Q, the nodes are ordered according to their assigned priority value. 
2. Prune the tree, popping one node at a time from the queue. Continue pruning until
    + The SQL that will be generated by the tree will have length <= L. OR
    + All the prunable nodes have already been pruned from the tree.

### (1) Generating a queue Q of nodes to be pruned:

At a high level, there are mainly two important decisions here:

#### Whether to prune a node or not?

AbbreviatorUtil class has an isAllowedToBePruned method, which returns a boolean given the node object. We add the node to the queue if this method returns true. The decision is based on a whitelist and blacklist. The reason behind this will be discussed later.

#### When to prune a node? 

Our goal is to get rid of the least “important” nodes first. So it would make sense to start removing the “bulkiest” parts of a tree, and keep doing that until we meet our goal. How do we define bulkiness? (1) Deeper the node, higher the bulkiness → less important it is. (2) Higher the number of siblings → less important it is.
    
The order of pruning is decided based on the value of tuple <cpVal, level> for every node. 

1. Defintion of `level` for a node:

    * Same as commonly used in the context of trees
  
    ```
    level(root) = 1
  
    level(child_node) = level(parent_node) + 1
    ```

2. Defintion of cpVal:

    + Definition of cpVal is dependent on the definition of pVal.
    + Definition of pVal:
  	
	```
	pVal(root) = 1.0

	pVal(child_node) = pVal(parent_node) / parent.getChildren().size()
	```
    
    + An example for computing pVals has been shown here. 

    + ![pVal example](https://github.com/phd1994/query-abbreviation-notes/blob/master/images/pVal.png "pVal computation")

    + pVal can be computed recursively and stored by traversing the whole tree. Two important invariants here: (1) child’s pVal is always less than or equal to parent’s pval. (2) All the children of a node have same pVal.

    + cpVal of a node is equal to the pVal of its children (if at least one exists). Otherwise, cpVal of a node is equal to the pVal of that node. 
  
  	```
	if a node has children:
		
		cpVal(node) = pval(any of its children)
	else:
		cpVal(node) = pVal(node)
	```

    * Psuedo code for order of pruning:

      ```java

      if ( cpVal(node_a) < cpVal(node_b)) {
          // prune node_a before node_b.
      }
      else if ( cpVal(node_a) == cpVal(node_b) ) {
          if ( level(node_a) > level(node_b) ) {
              // prune node_a before node_b.
          }
          else {
              // prune node_b before node_a.
          }	
      }
      else {
          // prune node_b before node_a.
      }
      ```

The nodes are added to a list during traversal for pruning using isAllowedToBePruned method. At the end, this list is sorted according to the order defined in the pseudo code.

#### Why are we using cpVal instead of pVal?

![cpVal example](https://github.com/phd1994/query-abbreviation-notes/blob/master/images/cpVal.png "Why cpVal?")

Consider the tree shown here. Assume that all nodes are allowed to be pruned. Intuitively, the 100 nodes named D_{\d+} should be pruned first. After pruning them, we will have "..." a hundred times in the generated sql. At this point, among all the unpruned nodes, node B is the one contributing the most to the "bulkiness" of the tree, and hence the SQL. So intuitively, B should be pruned before we prune E or F. But, pVal(B) = 1/2, and pVal(E)=pVal(F)=1/4. So, the node E and node F will get pruned before B, if we compare pVal values. Instead, if we compare cpVal, B will be picked first for pruning since cpVal(B) = 1/100 < 1/4 = cpVal(E). 

#### Why are we using level?

![level example](https://github.com/phd1994/query-abbreviation-notes/blob/master/images/level.png "Why level?")

It is possible for a node to have just one child. Consider the tree shown here. In such cases, we would like the child to get pruned before the node itself. Adding "level" to our comparator will take care of that.

### (2) Pruning the query tree:

After 

pruneQueryTree(root, L)


	currentSize = formatSql(root);
	
while(currentSize > L) {

	

}

	

Pruning a node means that we are replacing the text generate from the subtree rooted at that node by a marker [ variable PRUNED_MARKER in the code] 

Order of pruning