# Query Abbreviation in Presto

## Motivation

* Query-list.js makes a call to /v1/query/ endpoint, which returns a long list of queries. At times, when “query” field in QueryInfo object is too long (~1MB) for several queries, the REST call ends up fetching a lot of data from Presto Server. Instead of the whole query strings, sending a shorter version may allow us to reduce overall size of the response.

* (1) Pagination of query responses OR (2) Truncation of query strings are simple approaches that first come to mind to resolve this. The code in this PR takes a third approach, something a bit more involved, generating a shorter “abridged” version (that has length <= a configurable parameter L) for a query string without losing its sense. This can still be combined with approach (1) if required. And in case we fail to produce an abridged version <= L, we fall back to approach (2), i.e. truncation.

* Meaningful abbreviation of query strings seemed like an interesting problem in its own. For example, 

if we have a query

	`Select * from table_name where col1_name not in [‘val_1’, ‘val_2’, ….. ‘Val_2000’] and col2_name <= val_0.`

After shortening, it would be better to have 

	`Select * from table_name where col1_name not in [...] and col2_name <= 5`

Instead of

	`Select * from table_name where col1_name not in [‘val_1’, ‘val_2’, ‘val_3’, ‘v`
  
## Overview:

At a high level, the query abbreviation has been implemented as follows:

* An abridged version of the query string is generated by invoking the QueryAbbreviator during the creation of QueryStateMachine object. This object is passed to BasicQueryInfo constructor instead of the query itself, while returning the response from /v1/query endpoint.
* QueryAbbreviator does the following:
  + Generates a tree from the query string S using SqlParser. 
  + It keeps pruning nodes one-by-one from the tree until
    + The SQL that will be generated by the tree will have length <= L. OR
    + All the prunable nodes have already been pruned from the tree.

  + Returns the query string generated from the pruned tree. 

## Algorithm for abbreviation:

1. Generate a queue Q of nodes to prune. Only the nodes that return true from AbbreviatorUtil::isAllowedToBePruned can be added to the queue. In Q, the nodes are ordered according to their assigned priority value. 
2. Prune the tree, popping one node at a time from the queue. Continue pruning until
    + The SQL that will be generated by the tree will have length <= L. OR
    + All the prunable nodes have already been pruned from the tree.

Example of Pruning:

When we "prune" a node in the tree, we set a boolean member variable `node->pruned` to true. Any further invocations of formatSql method on a pruned node will return a string "..." instead of traversing the subtree. For example, take a look at the tree below.

![pruning example](https://github.com/phd1994/query-abbreviation-notes/blob/master/images/pruning.png "Pruning Example")

Initial sql: `val_0 not in (‘val_1’, 'val_2', 'val_3', 'val_4')`

After pruning 'val_1':  `val_0 not in ['...', ‘val_2', 'val_3', 'val_4']`

After pruning 'val_3':  `val_0 not in ['...', ‘val_2', '...', 'val_4']`

After pruning inExprList: `val_0 not in ...`

### (1) Generating a queue Q of nodes to be pruned:

At a high level, there are mainly two important decisions here:

#### Whether to prune a node or not?

AbbreviatorUtil class has an isAllowedToBePruned method, which returns a boolean given the node object. We add the node to the queue if this method returns true. The decision is based on a whitelist and blacklist. The reason behind this will be discussed later.

#### When to prune a node? 

Our goal is to get rid of the least “important” nodes first. So it would make sense to start removing the “bulkiest” parts of a tree, and keep doing that until we meet our goal. How do we define bulkiness? (1) Deeper the node, higher the bulkiness → less important it is. (2) Higher the number of siblings → less important it is.
    
The order of pruning is decided based on the value of tuple <cpVal, level> for every node. 

1. Defintion of `level` for a node:

    * Same as commonly used in the context of trees
  
    ```
    level(root) = 1
  
    level(child_node) = level(parent_node) + 1
    ```

2. Defintion of cpVal:

    + Definition of cpVal is dependent on the definition of pVal.
    + Definition of pVal:
  	
	```
	pVal(root) = 1.0

	pVal(child_node) = pVal(parent_node) / parent.getChildren().size()
	```
    
    + An example for computing pVals has been shown here. 

    + ![pVal example](https://github.com/phd1994/query-abbreviation-notes/blob/master/images/pVal.png "pVal computation")

    + pVal can be computed recursively and stored by traversing the whole tree. Two important invariants here: (1) child’s pVal is always less than or equal to parent’s pval. (2) All the children of a node have same pVal.

    + cpVal of a node is equal to the pVal of its children (if at least one exists). Otherwise, cpVal of a node is equal to the pVal of that node. 
  
  	```
	if a node has children:
		
		cpVal(node) = pval(any of its children)
	else:
		cpVal(node) = pVal(node)
	```

    * Psuedo code for order of pruning:

      ```java

      if ( cpVal(node_a) < cpVal(node_b)) {
          // prune node_a before node_b.
      }
      else if ( cpVal(node_a) == cpVal(node_b) ) {
          if ( level(node_a) > level(node_b) ) {
              // prune node_a before node_b.
          }
          else {
              // prune node_b before node_a.
          }	
      }
      else {
          // prune node_b before node_a.
      }
      ```

The nodes are added to a list during traversal for pruning using isAllowedToBePruned method. At the end, this list is sorted according to the order defined in the pseudo code.

#### Why are we using cpVal instead of pVal?

![cpVal example](https://github.com/phd1994/query-abbreviation-notes/blob/master/images/cpVal.png "Why cpVal?")

Consider the tree shown here. Assume that all nodes are allowed to be pruned. Intuitively, the 100 nodes named D_{\d+} should be pruned first. After pruning them, we will have "..." a hundred times in the generated sql. At this point, among all the unpruned nodes, node B is the one contributing the most to the "bulkiness" of the tree, and hence the SQL. So intuitively, B should be pruned before we prune E or F. But, pVal(B) = 1/2, and pVal(E)=pVal(F)=1/4. So, the node E and node F will get pruned before B, if we compare pVal values. Instead, if we compare cpVal, B will be picked first for pruning since cpVal(B) = 1/100 < 1/4 = cpVal(E). 

#### Why are we using level?

![level example](https://github.com/phd1994/query-abbreviation-notes/blob/master/images/level.png "Why level?")

It is possible for a node to have just one child. Consider the tree shown here. In such cases, we would like the child to get pruned before the node itself. Adding "level" to our comparator will take care of that.

### (2) Pruning the query tree:

Once we have a queue of nodes Q ordered such that they get popped from the queue in order of increasing importance, we are ready to prune the nodes one by one. `pruneQueryTree` algorithm works as follows:

* Pseudocode (simplified):

```
pruneQueryTree(root, Q, L) {

    currentSize = formatSql(root, PRUNE_AWARE);
	
    while(currentSize > L) {
        int changeInSize = pruneOneNode(Q);
        currentSize -= changeInSize;
    }
}

pruneOneNode() {

    Node nodeToPrune = Q.remove();

    String rootedSubTreeSql = SqlFormatter.formatSql(nodeToPrune, PRUNE_AWARE);
    String sqlAfterPruning = "...";
    
    // Set the flag
    nodeToPrune.setPruned();    

    return length(rootedSubTreeSql) - length(sqlAfterPruning);
}

```

SqlFormatter has a formatSql method which uses an instance of Formatter class to process the tree and generate Sql. This PR extends Formatter class to create a new PruneAwareFormatter implementation. PruneAwareFormatter is very similar to Formatter, except when node.isPruned() == true, it returns "..." instead of traversing the subtree.

pruneOneNode method does make a call to formatSql method, but with the PruneAwareFormatter implementation. After a node is pruned, the subtree will not be traversed in any future formatSql call. Therefore, the complexity of pruneQueryTree is NOT O(n^2). If the tree has n nodes, the complexity would be O(n).  

The actual implementation is a little bit more complicated due to (1) the way SqlFormatter and ExpressionFormatter have been implemented and (2) how indentation is propagated in SqlFormatter. ( This PR also makes some refactoring changes to SqlFormatter and ExpressionFormatter classes for PruneAwareFormatter implementation. )

***

#### Role of `isAllowedToBePruned` method

Some types of Nodes have been handled specially in SqlFormatter and ExpressionFormatter classes. For example, `With` and `WithQuery` nodes don't have a corresponding visit method. Nodes of type `Table` are treated differently when they are traversed through `visitQuery` method. A new `TableSubQuery` node is generated and processed within `visitQuery` method while traversing. The algorithm won't be able to prune such nodes, because formatSql calls will fail, when called on subtrees rooted at those nodes. isAllowedToBePruned method takes care of such cases. 

Another possible use of  `isAllowedToBePruned` method is to explicitly exclude nodes that we don't want to prune. For example, abbreviation for "SELECT * FROM abcd WHERE presto = awesome", results in "... FROM abcd WHERE ..." , because of how `visitQuerySpecification` is implemented. If we blackList SELECT class, we can abbreviate the query to "SELECT ... FROM abcd WHERE ..." instead.

***

#### Testing

`TestQueryAbbreviator` class tests the logic for abbreviation against a bunch of queries. Most of the queries are borrowed from TestStatementBuilder class. 